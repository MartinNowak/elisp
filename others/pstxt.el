;;; pstxt.el --- fixes the output of pstotext. 
;; Time-stamp: <2008-10-16 16:30:27 deego>
;; Copyright (C) 2002 D. Goel
;; Emacs Lisp Archive entry
;; Filename: pstxt.el
;; Package: pstxt
;; Author: D. Goel <deego@glue.umd.edu>
;; Keywords:  conversion LaTeX postscript dvi text pstotext text
;; Version: 0.2dev
;; Author's homepage: http://deego.gnufans.org/~deego
;; For latest version: 

(defconst pstxt-home-page
  "http://deego.gnufans.org/~deego")


 
;; This file is NOT (yet) part of GNU Emacs.
 
;; This is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
 
;; This is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.
 

;; See also:


;; Quick start:
(defconst pstxt-quick-start
  "Drop this file in your loadpath.  Add (require 'pstxt) to .emacs. 
Run latex, latex, dvips on your .tex file..  Get the .ps file, and
run pstotext file.ps > file.txt.
C-x C-f file.txt
M-x pstxt-buffer 
\[maybe Also try M-x pstxt-x-<commands>..]
M-x customize-group pstxt to frob stuff like pstxt-interactivity.")

(defun pstxt-quick-start ()
  "Provides electric help from variable `pstxt-quick-start'."
  (interactive)
  (with-electric-help
   '(lambda () (insert pstxt-quick-start) nil) "*doc*"))

;;; Introduction:
;; Stuff that gets posted to gnu.emacs.sources
;; as introduction
(defconst pstxt-introduction
  "This tries to fix the few remaining issues after a pstotext
conversion.  (Type M-x pstxt-quick-start).  

This is the result of my search for the best way to convert latex to
text.  I have tried several utilities, and if I missed something or am
trying to fix nonissues here, please do follow-up to this and let me
know (FUP set to: g.e.help).  It seems that pstotext does the best
job---other utilities I have tried are pdftotext, ps2ascii, ps2ps,
pdftotext. As compared to all these, pstotext seemed like near-perfect
to me. As of 2004-09, I think I prefer pdftotext more.   pstxt does
not deal well with ff, iff, ffi, etc.  pdftotext seems to be better
at that. 

So, the route here is: latex-->dvi-->ps--->text--->text 
using latex, dvips, pstotext and pstxt.el respectively.  

Actually, now i see that latex2html -ascii_mode -split 0, followed by
html2tex or lynx -dump seems to do a less kludgy job and better as far
as some still-remaining unfixable bugs are concerned.  So, I shall try
that route from now on, I think.  But that route may not always be
desirable, say because: it might(??) still convert some eqns to
images, or if for some reason (I did) you want the output filled
exactly as in the .ps file.  Or, if you do not have the latex file
available, but simply want to convert a dvi or ps or even pdf to
text.. And, latex2html often leaves some latex commands in there..

Tested on Gnu emacs 21.2 on gnulinux with pstotext v. 1.8g (jan
2000) which uses Ghostscript 6.53.  Type pstxt-quick-start, see also
commentary and Bugs.")

;;;###autoload
(defun pstxt-introduction ()
  "Provides electric help from variable `pstxt-introduction'."
  (interactive)
  (with-electric-help
   '(lambda () (insert pstxt-introduction) nil) "*doc*"))

;;; Commentary:
(defconst pstxt-commentary
  "The issues addressed here are:

Control characters generated by pstotext in place of ffi, ff
ffe, fl, etc. key combos are reverted.

\item items leading ^O are reverted as *. 

Some cool paragraph detection guesswork is done and newlines inserted.

Paras can then be filled, and the newpage ^L's can be removed."
)

(defun pstxt-commentary ()
  "Provides electric help from variable `pstxt-commentary'."
  (interactive)
  (with-electric-help
   '(lambda () (insert pstxt-commentary) nil) "*doc*"))

;;; History:

;;; Bugs:

;; A still remaining issue is that pdftotext converts { to f and } to
;; g.  I don't know how to fix that.

;; The detection of paragraph-ends is, by definition, kludgy.  It can
;; be made as smarter---as smart as we are!---but it will always
;; remain kludgy---the only proper solution is again to reform
;; pstotext to make it pass para-end information. 


;;; New features:
(defconst pstxt-new-features
  "Help..."
)

(defun pstxt-new-features ()
  "Provides electric help from variable `pstxt-new-features'."
  (interactive)
  (with-electric-help
   '(lambda () (insert pstxt-new-features) nil) "*doc*"))

;;; TO DO:
(defconst pstxt-todo
  "Help..."
)

(defun pstxt-todo ()
  "Provides electric help from variable `pstxt-todo'."
  (interactive)
  (with-electric-help
   '(lambda () (insert pstxt-todo) nil) "*doc*"))

(defconst pstxt-version "0.2dev")
(defun pstxt-version (&optional arg)
   "Display pstxt's version string. 
With prefix ARG, insert version string into current buffer at point."
  (interactive "P")
  (if arg
      (insert (message "pstxt version %s" pstxt-version))
    (message "pstxt version %s" pstxt-version)))

;;==========================================
;;; Code:
(require 'sregex)

(defgroup pstxt nil 
  "The group pstxt"
  :group 'applications)
(defcustom pstxt-before-load-hooks nil 
  "Hooks to run before loading pstxt"
  :group 'pstxt)
(defcustom pstxt-after-load-hooks nil 
  "Hooks to run after loading pstxt"
  :group 'pstxt)
(run-hooks 'pstxt-before-load-hooks)


(defcustom pstxt-verbosity 100
  "How verbose to be.  From -100 to 100. 
Once you are experienced with this library, 0 is the recommended value."
  :type 'integer
  :group 'pstxt)
(defcustom pstxt-interactivity 100
  "How interactive to be.  From -100 to 100. 
Once you are experienced, 0 is the recommended value."
  :type 'integer
  :group 'pstxt)

(defcustom pstxt-conversions 
  `(

    ;; ^L
    ;;(12 "fi")
    ((concat "[^\n]\\(" (string 12) "\\)[^\n]")
     "fi"  
     t 
     -5 1)



    ;; ^K
    (11 "ff" t -20)

    ;; #
    (35 "ff" t +20)

    ;; 2246 the strange f or the ? in emacs.. 
    ;;the one which shows up as <C6> in less
    (2246 "ffi" t -20)
    ;; ^M
    (13 "fl" t -10 )

    ;; \ opening quotes in latex 
    (92 "``" t -20) 

    ;; -SPC
    (,(string 2221 32) "" t 20)

    ;; This 15 is the ^O which shows up instead of bullets.. appears
    ;; on newlines, so adding a \n..
    ((concat "\n" (string 15)) 
     "\n*" 
     t 
     -20
    ))
    
  "List Conversions.
Of the form:
 (fromreg tostring default-value interactivity-value 
       subexp).

The fourth entry is added to pstxt-interactivity
to calculate threshold.  If the threshold exceeds 0, user is prompted
for confirmation for each substitution, else the result is taken as t
or nil from the third entry. 


The fifth entry subexp speifies what subexp number to replace when
performing the replace-match. 

More entries may be added to this at a later stage. 

The fromreg can be either a regexp, or an expression or a character or
a character number or an expression. 

If it is a character, then the string gotten from the characters is
regexp-quoted.  If the fromstring is an expression, the expression is
EVALLED to get the fromstring. "
  :group 'pstxt
  :type 'list
  )


(defcustom pstxt-para-new-threshold 65
  "New para threshold.  

If output ends before this, we must be looking at a new para. "
  :type 'integer
  :group 'pstxt
  )





(defcustom pstxt-interactivity-para -5
  "Additional interactivity for para-fixing mode.."
  :type 'integer
  :group 'pstxt)

(defcustom pstxt-para-unfix-characters 
  ;; newline=10, ^L=12
  '(10 )
  "Don't fix if the next char belongs to one of above.."
  :type 'integer
  :group 'pstxt)


(defcustom pstxt-y-or-n-p-function 'pstxt-y-or-n-p
  "Function to use for interactivity-dependent  y-or-n-p.
Format same as that of `pstxt-y-or-n-p'"
  :type 'function
  :group 'pstxt)


(defcustom pstxt-n-or-y-p-function 'pstxt-n-or-y-p
  "Function to use for interactivity-dependent  y-or-n-p.
Format same as that of `pstxt-y-or-n-p'"
  :type 'function
  :group 'pstxt)


;;;###autoload
(defun pstxt-buffer ()
  (interactive)
  (pstxt-convert-all)
  (pstxt-para-fix)
  (pstxt-message 
   20
   "Done pstxt-buffer.. try M-x pstxt-x-fill or M-x pstxt-x-command")
  )



;;;###autoload
(defun pstxt-convert-all ()
  (interactive)
  (mapcar 'pstxt-convert pstxt-conversions))

(defun pstxt-convert (conversion)
  (let ((fromgiven (first conversion))
	(to (second conversion)) 
	from
	(default (eval (third conversion)))
	(add (eval (fourth conversion)))
	(subexp (eval (fifth conversion)))
	)
    (cond
     ((listp fromgiven) (setq from (eval fromgiven)))
     ((numberp fromgiven) 
      (setq from (regexp-quote (string fromgiven))))
     ;; hopefully a string..
     (t (setq from fromgiven)))
    (goto-char (point-min))
    (pstxt-query-replace-regexp 
     from to 
     (if default pstxt-y-or-n-p-function pstxt-n-or-y-p-function)
     subexp
     (if (numberp add) add 0)))
  (replace-dehighlight))


(defun pstxt-query-replace-regexp (from to &optional query-fcn subexp &rest args)
  "Replaces regexps FROM by TO. 

SUBEXP is the subexp argument passed to `replace-match'. 

The query-function should follow the same format as that of
pstxt-y-or-n-p.  ARGS are passed to the query function. 

Thus, the first arg is an interactivity. 


This function will create the missing arguments by
itself.. viz. If the second arg is nil, this function creates a prompt
--- so, we recommend that you skip the
prompt argument when calling this function :-) "
  (let ((prompt (second args))
	(add (first args))
	(subexp1 (or subexp 0)))
    (unless (numberp add) (setq add 0))
    (unless query-fcn
      (setq query-fcn 'pstxt-y-or-n-p))
    (while (search-forward-regexp from nil t)
      (pstxt-replace-highlight (match-beginning subexp1)
			 (match-end subexp1))
      (when 
	  (funcall 
	   query-fcn add
	   (or prompt (concat "Replace " (match-string subexp1) 
			      " by " to " ?")))
	(replace-match to t nil nil subexp)))))

(defun pstxt-message (points &rest args)
  "Signal message, depending on POINTS andpstxt-verbosity.
ARGS are passed to `message'."
  (unless (minusp (+ points pstxt-verbosity))
    (apply #'message args)))

(defun pstxt-y-or-n-p (add prompt)
  (if (>= (+ add pstxt-interactivity) 0)
      (funcall 'y-or-n-p prompt)
    t))



;;; 2002-05-03 T11:05:43-0400 (Friday)    D. Goel
(defun pstxt-n-or-y-p (add prompt)
  (if (>= (+ add pstxt-interactivity) 0)
      (funcall 'y-or-n-p prompt)
    nil))



;;;###autoload
(defun pstxt-para-fix ()
  "
Future suggestions:  pstxt could intelligently fix it on its own---by
defining a score based on:  (current-column), presence-of-period at
this line, and Capital character on next line..

In fact, the query-replace thing for here can be fuzzy as well.. if it
is not too sure, it can ask us..."
  (interactive)
  (goto-char (point-min))
  (while (search-forward "\n" nil t)
    (when (and (< (pstxt-previous-column) pstxt-para-new-threshold )
	       (not (member (char-after) pstxt-para-unfix-characters))
	       (not (member (pstxt-char-previous) 
			    pstxt-para-unfix-characters)))
      (unless (bobp) (pstxt-replace-highlight (point) (- (point) 1)))
      (when 
	  (pstxt-y-or-n-p (- pstxt-interactivity-para 5)
			  "Insert newline here? ")
	(replace-match "\n\n"))))
  (replace-dehighlight))


(defun pstxt-previous-column ()
  (save-excursion
    (let ((col
	   (progn
	     (unless (bobp)
	       (backward-char 1))
	     (current-column))))
      (if (integerp col) col 0))))



(defun pstxt-char-previous ()
  (save-excursion
    (let ((char
	   (progn
	     (unless (bobp)
	       (backward-char 1))
	     (char-before))))
      char)))

;;;====================================================
;; Other utilities
;; The interactive pstxt-x-  commands are "extra" commands..

(defcustom pstxt-fill-argument nil
  "Argument to fill-paragraph. 
Use when calling the extra \\[pstxt-bufferfill]."
  :group 'pstxt
  )

;;;###autoload
(defun pstxt-x-remove-ctrl-l ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((ctrll (string 12)))
      (while (search-forward ctrll nil t)
	(unless (bobp) (pstxt-replace-highlight (point) (- (point) 1)))
	(when (pstxt-y-or-n-p (- pstxt-interactivity-para 40)
			      "Replace this ^L?")
	  (replace-match "\n")))))
  (replace-dehighlight))


;;;###autoload
(defun pstxt-x-fill ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (fill-paragraph pstxt-fill-argument)
    (let ((pt (point)))
      (while (not (eobp))
	(forward-paragraph 1)
	(pstxt-replace-highlight pt (point))
	(when (pstxt-y-or-n-p (- pstxt-interactivity-para 20)
			      "Fill this paragraph?")
	  (fill-paragraph pstxt-fill-argument))
	(setq pt (point))
	)))
  (replace-dehighlight))


;;;###autoload
(defun pstxt-x-unfill-region (a b)
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region a b)
      (pstxt-x-unfill-buffer))))

;;;###autoload
(defun pstxt-x-unfill-buffer ()
  "If you are not in text-mode, you most likely want to run
M-x text-mode before calling this command."
  (interactive)
  (let ((fill-column 99999)
	(pstxt-interactivity-para (- pstxt-interactivity-para 40)))
    (pstxt-x-fill)))

;;;###autoload
(defun pstxt-x-unfill-paragraph ()
  "If you are not in text-mode, you most likely want to run
M-x text-mode before calling this command."
  (interactive)
  (let ((fill-column 99999))
    (fill-paragraph nil)))




(defun pstxt-replace-highlight (a b)
  (cond
   ((>= emacs-major-version 22)
    (let ((query-replace-highlight t)
	  (query-replace-lazy-highlight nil))
      (replace-highlight a b nil nil nil nil nil)))
   (t
    (replace-highlight a b))))

(provide 'pstxt)
(run-hooks 'pstxt-after-load-hooks)



;;; pstxt.el ends here
